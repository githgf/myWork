# 运行时的数据区域

![JVM运行时数据区域](jvm_memory.PNG)

## 方法区

方法区是储存已经被虚拟机加载类的具体信息：属性字段、常量、静态变量、结构体信息、方法数据、构造函数...，同时方法区是**线程共享**的

java虚拟机规定方法区是堆的逻辑部分，别名非堆（no-heap）

### 运行时常量池

储存编译期生成的字面量和符号引用，其储存在方法区中是**线程共享**的

![jvm运行时常量池](jvm运行时常量池.png)

## 堆

是虚拟机中内存占用最大的一块区域，主要存储运行时实例对象的数据，同时也是gc（垃圾回收）主要管理区域，所以也称为gc堆，是线程共享的

根据虚拟机规定，堆可以是在物理内存中不连续的，只要逻辑上连续即可

## 程序计数器（pc寄存器）

Program Counter Register

当前线程所执行的字节码的行号指示器，虚拟机根据计数器选取下一条需要执行的字节码指令（循环、跳转、分支、异常处理....）

当调用java方法时计数器中的值就是正在执行的字节码

当调用native原生方法时赋为空值

## 虚拟机栈

存储线程运行所需要的栈帧结构，并且将线程运行方法引用装配到栈帧中，然后依次入栈运行方法，包含线程运行所需要的类的引用，每一个线程都会分配一个虚拟机栈

### 栈帧

个人理解一个栈帧就是一个方法，方法的运行和结束对应栈帧的出栈和入栈，所以栈帧中需要包含方法运行的局部变量、动态链接、操作数栈等关键信息，每一个栈帧包含一个在运行时常量池中所属方法的引用

#### 局部变量

当前运行方法所需要的变量值引用

#### 动态链接

当前运行的方法中包含了其他方法的引用，就会产生动态链接

通俗讲，当方法1中调用方法2，那么在方法2执行结束之后继续运行方法1，虚拟机需要知道在运行方法2之前已经运行到方法1中的那个阶段，相当于一个标记

#### 操作数栈

将运行的操作按照顺序入栈，假设1+1-2，总要将+、- 存储下



# 对象

## 对象的创建

1.当我们使用new关键字等方式创建一个的类的时候，虚拟机首先会看看这个类是否已经被加载，

​	如果没有，实现类的加载过程

2.如果有被加载则根据加载时确定的对象大小在内存中分配指定的大小，

​	其中如果java堆中的内存是规整的（空闲的一块、占用的一块）那么只需要将占用的指针向空闲的内存中方向进行移动即可。

​	如果不是规整的，那么jvm需要一个记录表，记录哪些空间是空闲的，哪些是被占用的。

这一过程其实就是将对象的名字指向一个内存地址值

同时为了防止对象的指针被频繁操作，jvm还采用了类似于CAS事务保证操作的原子性

3.分配完内存空间之后，要给对象中的字段、属性值赋予初始值

## 对象的存储布局