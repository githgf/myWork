# 运行时的数据区域

![JVM运行时数据区域](jvm_memory.PNG)

## 方法区

方法区是储存已经被虚拟机加载类的具体信息：属性字段、常量、静态变量、结构体信息、方法数据、构造函数...，同时方法区是**线程共享**的

java虚拟机规定方法区是堆的逻辑部分，别名非堆（no-heap）

### 运行时常量池

储存编译期生成的字面量和符号引用，其储存在方法区中是**线程共享**的

![jvm运行时常量池](jvm运行时常量池.png)

## 堆

是虚拟机中内存占用最大的一块区域，主要存储运行时实例对象的数据，同时也是gc（垃圾回收）主要管理区域，所以也称为gc堆，是线程共享的

根据虚拟机规定，堆可以是在物理内存中不连续的，只要逻辑上连续即可

## 程序计数器（pc寄存器）

Program Counter Register

当前线程所执行的字节码的行号指示器，虚拟机根据计数器选取下一条需要执行的字节码指令（循环、跳转、分支、异常处理....）

当调用java方法时计数器中的值就是正在执行的字节码

当调用native原生方法时赋为空值

## 虚拟机栈

存储线程运行所需要的栈帧结构，并且将线程运行方法引用装配到栈帧中，然后依次入栈运行方法，包含线程运行所需要的类的引用，每一个线程都会分配一个虚拟机栈

### 栈帧

个人理解一个栈帧就是一个方法，方法的运行和结束对应栈帧的出栈和入栈，所以栈帧中需要包含方法运行的局部变量、动态链接、操作数栈等关键信息，每一个栈帧包含一个在运行时常量池中所属方法的引用

#### 局部变量

当前运行方法所需要的变量值引用

#### 动态链接

当前运行的方法中包含了其他方法的引用，就会产生动态链接

通俗讲，当方法1中调用方法2，那么在方法2执行结束之后继续运行方法1，虚拟机需要知道在运行方法2之前已经运行到方法1中的那个阶段，相当于一个标记

#### 操作数栈

将运行的操作按照顺序入栈，假设1+1-2，总要将+、- 存储下















































